using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using Kusto.Cloud.Platform.Data;
using Kusto.Cloud.Platform.Utils;

namespace Kusto.Charting
{
    #region class HierarchyAutoPivot
    /// <summary>
    /// An abstract base class for implementations of a hierarchy
    /// AutoPivot.
    /// </summary>
    public abstract class HierarchyAutoPivot
    {
        /// <summary>
        /// Determines if this data set is "interesting" to pivot as
        /// a hierarchy. This is the first method called on the interface,
        /// and it it returns false, no other method on the interface will be called.
        /// </summary>
        public abstract bool IsInterestingAsHierarchy(DataTable data);

        /// <summary>
        /// Returns an optional list of "banners" - lines with severity that are
        /// displayed to the user and provides helpful information.
        /// </summary>
        public virtual IEnumerable<Tuple<TraceVerbosity, string>> GetBanners()
        {
            return Enumerable.Empty<Tuple<TraceVerbosity, string>>();
        }

        /// <summary>
        /// Given a record, extract the activity and optionally the parent activity
        /// information out of it.
        /// </summary>
        public abstract TimePivot.NodeAndParentId GetNodeIdAndOptionallyParentNodeId(DataRow row);

        /// <summary>
        /// Given a tree node generated by this class, add any interesting property
        /// there is to it.
        /// </summary>
        public abstract void AddInterestingProperties(TimePivotTreeNode node);

        /// <summary>
        /// A display string identifying which "axis" serves as the hierarchy axis.
        /// </summary>
        public abstract string HierarchyAxis { get; }
    }
    #endregion

    #region class TestActivityHierarchyAutoPivot
    /// <summary>
    /// An implementation of <see cref="HierarchyAutoPivot"/> for testing purposes.
    /// </summary>
    public class TestActivityHierarchyAutoPivot : HierarchyAutoPivot
    {
        private DataColumn m_col_TS; // Timestamp
        private DataColumn m_col_AI; // ActivityId
        private DataColumn m_col_ET; // EventType: SetParentActivityId, SetActivityType, SetDuration, SetResult, Message
        private DataColumn m_col_EP; // EventPayload

        private string c_sampleData = @"
datatable(TS:datetime, AI:string, ET:string, EP:string)[
// Root activity
datetime(2017-01-01),       'A01', 'SetParentActivityId', 'A01',
datetime(2017-01-01),       'A01', 'SetActivityType', 'AType',
datetime(2017-01-02),       'A01', 'SetDuration', '1d',
datetime(2017-01-02),       'A01', 'SetResult', 'Info',
datetime(2017-01-01 00:10), 'A01', 'Message', 'First 10 minutes',
datetime(2017-01-01 01:10), 'A01', 'Message', 'After an hour',
datetime(2017-01-01 02:10), 'A01', 'Message', 'After two hours',
datetime(2017-01-01 03:10), 'A01', 'Message', 'Three',
datetime(2017-01-01 04:10), 'A01', 'Message', 'Four',
datetime(2017-01-01 05:10), 'A01', 'Message', 'Five',
datetime(2017-01-01 06:10), 'A01', 'Message', 'Six',
datetime(2017-01-01 07:10), 'A01', 'Message', 'Seven (and last)',
// Child activity
datetime(2017-01-01 05:30), 'A02', 'SetParentActivityId', 'A01',
datetime(2017-01-01 05:30), 'A02', 'SetActivityType', 'BType',
datetime(2017-01-01 23:10), 'A02', 'SetDuration', '10h',
datetime(2017-01-02 06:00), 'A02', 'SetResult', 'Error',
datetime(2017-01-01 06:11), 'A02', 'Message', 'Child`s first message',
datetime(2017-01-01 06:11), 'A02', 'Message', 'Child`s last message',
datetime(2017-01-02 03:00), 'A02', 'Message', 'A post-last message from the rogue child which extends beyond everything',
// Child activity with zero duration
datetime(2017-01-01 12:00), 'A03', 'SetParentActivityId', 'A01',
datetime(2017-01-01 12:00), 'A03', 'SetActivityType', 'CType',
datetime(2017-01-01 12:00), 'A03', 'SetDuration', '0h',
datetime(2017-01-01 12:00), 'A03', 'SetResult', 'Info',
datetime(2017-01-01 12:00), 'A03', 'Message', 'Only one?'
]
// | render timepivot 
";

        public TestActivityHierarchyAutoPivot()
        {
            Ensure.ValueIsUsed(c_sampleData);
        }

        public override bool IsInterestingAsHierarchy(DataTable data)
        {
            Ensure.ArgIsNotNull(data, "data");

            SetInterestingColumns(data);
            if (m_col_AI == null || m_col_TS == null)
            {
                return false;
            }
            return true;
        }

        public override TimePivot.NodeAndParentId GetNodeIdAndOptionallyParentNodeId(DataRow row)
        {
            if (m_col_ET == null || m_col_EP == null)
            {
                return new TimePivot.NodeAndParentId("ActivityId", (string)row[m_col_AI]);
            }

            var et = (string)row[m_col_ET];
            var ep = (string)row[m_col_EP];
            if (et != "SetParentActivityId")
            {
                return new TimePivot.NodeAndParentId("ActivityId", (string)row[m_col_AI]);
            }

            return new TimePivot.NodeAndParentId("ActivityId", (string)row[m_col_AI], "ActivityId", ep);
        }

        public override void AddInterestingProperties(TimePivotTreeNode node)
        {
            if (m_col_ET == null || node.Rows == null || m_col_EP == null)
            {
                return;
            }

            foreach (DataRow row in node.Rows)
            {
                var et = (string)row[m_col_ET];
                var ep = (string)row[m_col_EP];
                if (string.IsNullOrWhiteSpace(ep))
                {
                    continue;
                }
                switch (et)
                {
                    case "SetParentActivityId":
                        break;
                    case "SetActivityType":
                        node.SetProperty("ActivityType", ep);
                        break;
                    case "SetDuration":
                        {
                            // Payload is the duration
                            var duration = Kusto.Data.Common.CslTimeSpanLiteral.Parse(ep);
                            if (duration.HasValue)
                            {
                                var ended = ((DateTime)row[m_col_TS]).ToUtc();
                                var started = ended - duration.Value;
                                node.SetReportedTimeRange(new DateTimeRange(started, ended));
                            }
                            break;
                        }
                    case "SetResult":
                        // "Info", "Error", etc.
                        node.SetCategory(ep);
                        break;
                    case "Message":
                        break;
                    default:
                        break;
                }
            }
        }

        public override string HierarchyAxis { get { return "ActivityId"; } }

        private void SetInterestingColumns(DataTable data)
        {
            var columns = data.Columns;

            var ts = columns["TS"];
            if (ts != null && ts.DataType == typeof(DateTime))
            {
                m_col_TS = ts;
            }

            var ai = columns["AI"];
            if (ai != null && ai.DataType == typeof(string))
            {
                m_col_AI = ai;
            }

            var et = columns["ET"];
            if (et != null && et.DataType == typeof(string))
            {
                m_col_ET = et;
            }

            var ep = columns["EP"];
            if (ep != null && ep.DataType == typeof(string))
            {
                m_col_EP = ep;
            }
        }
    }
    #endregion

    #region class KustoActivityHierarchyAutoPivot
    /// <summary>
    /// Given a rectangular data source (a <see cref="DataTable"/>), determines
    /// if the data source contains Kusto activity traces in it and if so,
    /// returns the activity hierarchy.
    /// </summary>
    public class KustoActivityHierarchyAutoPivot : HierarchyAutoPivot
    {
        #region Private data;
        private const string c_paidEquals = "ParentActivityId=";
        private static readonly int c_paidEqualsLength = c_paidEquals.Length;
        private static readonly int c_guidLength = 36;
        private const string c_activitySucceeded = "MonitoredActivityCompletedSuccessfully";
        private const string c_activityFailed = "MonitoredActivityCompletedWithFailure";
        private const string c_duration_ms = "Duration=";

        private DataColumn m_timestampColumn;
        private DataColumn m_activityIdColumn;
        private DataColumn m_activityTypeColumn;
        private DataColumn m_eventTextColumn;
        #endregion

        #region Construction
        public KustoActivityHierarchyAutoPivot()
        {
        }
        #endregion

        #region Public API
        public override bool IsInterestingAsHierarchy(DataTable data)
        {
            Ensure.ArgIsNotNull(data, "data");

            SetInterestingColumns(data);
            if (m_activityIdColumn == null || m_eventTextColumn == null)
            {
                return false;
            }

            // Now walk the data, looking for our telltale pattern.
            // As soon as we find a row from which we can extract a parent activity ID
            // we declare the data a worthy candidate for this visualization.
            int nRows = 0;
            Guid parentActivityId = Guid.Empty;
            foreach (DataRow row in data.Rows)
            {
                if (TryLocateParentActivityId(row, ref parentActivityId))
                {
                    return true;
                }

                // Don't probe too much
                if (++nRows > 100000)
                {
                    break;
                }
            }

            return false;
        }

        public override TimePivot.NodeAndParentId GetNodeIdAndOptionallyParentNodeId(DataRow row)
        {
            var name = "ActivityId";
            var value = (string)row[m_activityIdColumn];
            if (string.IsNullOrWhiteSpace(value))
            {
                value = "##empty";
            }

            Guid parentActivityId = Guid.Empty;
            if (TryLocateParentActivityId(row, ref parentActivityId))
            {
                // TODO: Perhaps change the interface of TryLocate... so that we won't need to re-print the parentActivityId
                return new TimePivot.NodeAndParentId("ActivityId", value, "ActivityId", parentActivityId.ToString());
            }
            return new TimePivot.NodeAndParentId(name, value);
        }

        public override void AddInterestingProperties(TimePivotTreeNode node)
        {
            if (node.Rows != null)
            {
                foreach (DataRow row in node.Rows)
                {
                    var activityType = (string)row[m_activityTypeColumn];
                    if (!string.IsNullOrWhiteSpace(activityType))
                    {
                        node.SetProperty("ActivityType", activityType);
                    }

                    bool processDuration = false;
                    var eventText = (string)row[m_eventTextColumn];
                    if (!string.IsNullOrWhiteSpace(eventText))
                    {
                        if (eventText.StartsWith(c_activitySucceeded, StringComparison.Ordinal))
                        {
                            processDuration = true;
                            node.SetCategory("Info");
                        }
                        else if (eventText.StartsWith(c_activityFailed, StringComparison.Ordinal))
                        {
                            processDuration = true;
                            node.SetCategory("Error");
                        }
                    }

                    if (processDuration && m_timestampColumn != null)
                    {
                        var duration_ms_index = eventText.IndexOf(c_duration_ms, StringComparison.Ordinal);
                        if (duration_ms_index >= 0)
                        {
                            duration_ms_index += c_duration_ms.Length;
                            var duration_ms_end_index = eventText.IndexOf(' ', duration_ms_index);
                            if (duration_ms_end_index >= 0)
                            {
                                double duration_ms;
                                if (double.TryParse(eventText.Substring(duration_ms_index, duration_ms_end_index - duration_ms_index), out duration_ms))
                                {
                                    if (duration_ms >= 0)
                                    {
                                        DateTime ended = ((DateTime)row[m_timestampColumn]).ToUtc(); // TODO: Add code to protect against DBNull values and invalid values?
                                        DateTime started = ended - TimeSpan.FromMilliseconds(duration_ms);
                                        node.SetReportedTimeRange(new DateTimeRange(started, ended));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public override string HierarchyAxis { get { return "ActivityId"; } }
        #endregion

        #region Private implementation
        private void SetInterestingColumns(DataTable data)
        {
            var columns = data.Columns;

            // We must have at least two columns:
            // - ActivityID of type string
            // - EventText of type string
            var activityIdcolumn = columns["ActivityID"];
            if (activityIdcolumn != null && activityIdcolumn.DataType == typeof(string))
            {
                m_activityIdColumn = activityIdcolumn;
            }

            // We don't need this to construct the tree, but it's useful for display purposes:
            var activityTypeColumn = columns["ActivityType"];
            if (activityTypeColumn != null && activityTypeColumn.DataType == typeof(string))
            {
                m_activityTypeColumn = activityTypeColumn;
            }

            var eventTextColumn = columns["EventText"];
            if (eventTextColumn != null && eventTextColumn.DataType == typeof(string))
            {
                m_eventTextColumn = eventTextColumn;
            }

            var timestampColumn = columns["Timestamp"];
            if (timestampColumn != null && timestampColumn.DataType == typeof(DateTime))
            {
                m_timestampColumn = timestampColumn;
            }
        }

        private bool TryLocateParentActivityId(DataRow row, ref Guid parentActivityId)
        {
            var eventText = (string)row[m_eventTextColumn];
            if (eventText == null)
            {
                return false;
            }

            if (!eventText.StartsWith("MonitoredActivity", StringComparison.Ordinal))
            {
                return false;
            }

            var paidIndex = eventText.IndexOf(c_paidEquals, StringComparison.Ordinal);
            if (paidIndex < -1 || paidIndex + c_paidEqualsLength + c_guidLength > eventText.Length)
            {
                return false;
            }

            var parentActivityIdString = eventText.Substring(paidIndex + c_paidEqualsLength, c_guidLength);
            if (Guid.TryParse(parentActivityIdString, out parentActivityId))
            {
                return true;
            }
            return false;
        }
        #endregion
    }
    #endregion

    #region class IfxOperationHierarchyAutoPivot
    /// <summary>
    /// Given a rectangular data source (a <see cref="DataTable"/>), determines
    /// if the data source contains Kusto activity traces in it and if so,
    /// returns the activity hierarchy.
    /// </summary>
    public class IfxOperationHierarchyAutoPivot : HierarchyAutoPivot
    {
        #region Private data;
        private static readonly int c_guidLength = 36;
        private static readonly string c_emptyGuidString = Guid.Empty.ToString();

        private DataColumn m_col_durationMs_uint32;    // "durationMs" of type uint32
        private DataColumn m_col_durationMs_int64;     // "durationMs" of type int64
        private DataColumn m_col_env_cv;        // "env_cv" of type string
        private DataColumn m_col_env_name;      // "env_name" of type string
        private DataColumn m_col_env_time;      // "env_time" of type DateTime
        private DataColumn m_col_operationName; // "operationName" of type string
        private DataColumn m_col_operationType; // "operationType" of type string
        private DataColumn m_col_resultType;    // "resultType" of type string (values: "Success", "Failure")
        #endregion

        #region Construction
        public IfxOperationHierarchyAutoPivot()
        {
        }
        #endregion

        #region Public API
        public override bool IsInterestingAsHierarchy(DataTable data)
        {
            Ensure.ArgIsNotNull(data, "data");

            SetInterestingColumns(data);
            if (m_col_env_cv == null)
            {
                return false;
            }

            // Now walk the data, looking for our telltale pattern
            int nRows = 0;
            int nSuccesses = 0;
            Guid rootOperationId = Guid.Empty;
            Guid parentOperationId = Guid.Empty;
            Guid operationId = Guid.Empty;
            foreach (DataRow row in data.Rows)
            {
                if (IsEnvCvProperlyFormatted(row, ref rootOperationId, ref parentOperationId, ref operationId))
                {
                    nSuccesses++;
                }

                // Don't probe too much
                if (++nRows > 10000)
                {
                    break;
                }
            }

            if (nSuccesses > 3 && nSuccesses * 100 > nRows)
            {
                return true;
            }
            return false;
        }

        public override IEnumerable<Tuple<TraceVerbosity, string>> GetBanners()
        {
            Ensure.ConditionIsMet(m_col_env_cv != null, "env_cv must be available or this method should not have been called");

            var ret = new List<Tuple<TraceVerbosity, string>>();
            if (m_col_env_name == null)
            {
                ret.Add(Tuple.Create(TraceVerbosity.Error, "Column 'env_name' is missing; hierarchy cannot be determined."));
                return ret; // No point in adding warnings once we have this error.
            }
            var missingColumns = new List<string>();
            if (m_col_env_time == null) { missingColumns.Add("env_time"); }
            if (m_col_operationName == null) { missingColumns.Add("operationName"); }
            if (m_col_operationType == null) { missingColumns.Add("operationType"); }
            if (m_col_resultType == null) { missingColumns.Add("resultType"); }
            if (m_col_durationMs_int64 == null && m_col_durationMs_uint32 == null) { missingColumns.Add("durationMs"); }

            if (missingColumns.Count == 1)
            {
                ret.Add(Tuple.Create(TraceVerbosity.Warning, $"Column '{missingColumns.First()}' is missing; it is recommend that you add it to the result set for better experience."));

            }
            else if (missingColumns.Count > 1)
            {
                var columns = "{" + string.Join(", ", missingColumns.Select(c => "'" + c + "'")) + "}";
                ret.Add(Tuple.Create(TraceVerbosity.Warning, $"Columns {columns} are missing; it is recommend that you add them to the result set for better experience."));
            }
            return ret;
        }

        public override TimePivot.NodeAndParentId GetNodeIdAndOptionallyParentNodeId(DataRow row)
        {
            Guid rootOperationId = Guid.Empty;
            Guid parentOperationId = Guid.Empty;
            Guid operationId = Guid.Empty;
            if (IsEnvCvProperlyFormatted(row, ref rootOperationId, ref parentOperationId, ref operationId))
            {
                if (parentOperationId != Guid.Empty)
                {
                    return new TimePivot.NodeAndParentId("OperationId", operationId.ToString(), "OperationId", parentOperationId.ToString());
                }
                return new TimePivot.NodeAndParentId("OperationId", operationId.ToString());
            }
            // TODO: What do we return if we couldn't parse the env_cv?
            return new TimePivot.NodeAndParentId("OperationId", c_emptyGuidString);
        }

        public override void AddInterestingProperties(TimePivotTreeNode node)
        {
            if (node.Rows != null)
            {
                foreach (DataRow row in node.Rows)
                {
                    if (m_col_env_name != null
                        && "#Ifx.OperationSchema" == row.GetValueAsTypeOrDefault<string>(m_col_env_name))
                    {
                        // This is the Ifx event that reports the operation completion.
                        // Use all well-known and interesting data that it has (if it has them).
                        // Note: We rely here on the fact that GetValueAsTypeOrDefault returns the default
                        //       if the column is null.
                        long durationMs = Int64.MaxValue;
                        var durationMs_uint32 = row.GetValueAsTypeOrDefault<UInt32>(m_col_durationMs_uint32, UInt32.MaxValue);
                        if (durationMs_uint32 != UInt32.MaxValue)
                        {
                            durationMs = durationMs_uint32;
                        }
                        else 
                        {
                            durationMs = row.GetValueAsTypeOrDefault<Int64>(m_col_durationMs_int64, Int64.MaxValue);
                        }

                        var env_time = row.GetValueAsTypeOrDefault<DateTime>(m_col_env_time);
                        if (env_time > DateTime.MinValue && durationMs != Int64.MaxValue)
                        {
                            env_time = env_time.ToUtc();
                            var started = env_time - TimeSpan.FromMilliseconds(durationMs);
                            var ended = env_time;
                            node.SetReportedTimeRange(new DateTimeRange(started, ended));
                        }

                        var operationName = row.GetValueAsTypeOrDefault<string>(m_col_operationName);
                        if (!string.IsNullOrWhiteSpace(operationName))
                        {
                            node.SetProperty("OperationName", operationName);
                        }

                        var operationType = row.GetValueAsTypeOrDefault<string>(m_col_operationType);
                        if (!string.IsNullOrWhiteSpace(operationType))
                        {
                            node.SetProperty("OperationType", operationType);
                        }

                        var resultType = row.GetValueAsTypeOrDefault<string>(m_col_resultType);
                        if (!string.IsNullOrWhiteSpace(resultType))
                        {
                            var category
                                = resultType == "Success"
                                ? "Info"
                                : resultType == "Failure"
                                ? "Error"
                                : "Warning";
                            node.SetCategory(category);
                        }
                    }
                }
            }
        }

        public override string HierarchyAxis { get { return "OperationId"; } }
        #endregion

        #region Private implementation
        private void SetInterestingColumns(DataTable data)
        {
            var columns = data.Columns;

            var durationMsColumn = columns["durationMs"];
            if (durationMsColumn != null && durationMsColumn.DataType == typeof(UInt32))
            {
                m_col_durationMs_uint32 = durationMsColumn;
            }

            if (durationMsColumn != null && durationMsColumn.DataType == typeof(Int64))
            {
                m_col_durationMs_int64 = durationMsColumn;
            }

            // To be interesting, the data must have a column called "env_cv"
            // of type string
            var envCvColumn = columns["env_cv"];
            if (envCvColumn != null && envCvColumn.DataType == typeof(string))
            {
                m_col_env_cv = envCvColumn;
            }

            var envNameColumn = columns["env_name"];
            if (envNameColumn != null && envNameColumn.DataType == typeof(string))
            {
                m_col_env_name = envNameColumn;
            }

            var envTimeColumn = columns["env_time"];
            if (envTimeColumn != null && envTimeColumn.DataType == typeof(DateTime))
            {
                m_col_env_time = envTimeColumn;
            }

            var operationNameColumn = columns["operationName"];
            if (operationNameColumn != null && operationNameColumn.DataType == typeof(string))
            {
                m_col_operationName = operationNameColumn;
            }

            var operationTypeColumn = columns["operationType"];
            if (operationTypeColumn != null && operationTypeColumn.DataType == typeof(string))
            {
                m_col_operationType = operationTypeColumn;
            }

            var resultTypeColumn = columns["resultType"];
            if (resultTypeColumn != null && resultTypeColumn.DataType == typeof(string))
            {
                m_col_resultType = resultTypeColumn;
            }
        }

        private bool IsEnvCvProperlyFormatted(DataRow row, ref Guid rootOperationId, ref Guid parentOperationId, ref Guid operationId)
        {
            var env_cv = (string)row[m_col_env_cv];
            if (env_cv == null)
            {
                return false;
            }

            // env_cv is formatted like so:
            // `##` *rootOperationId* `_` *parentOperationId* `_` *operationId*
            var expectedLength = 2 + c_guidLength + 1 + c_guidLength + 1 + c_guidLength;
            if (env_cv.Length != expectedLength)
            {
                return false;
            }

            if (!env_cv.StartsWith("##", StringComparison.Ordinal))
            {
                return false;
            }

            var rootOperationIdStr = env_cv.Substring(2, c_guidLength);
            if (!Guid.TryParse(rootOperationIdStr, out rootOperationId))
            {
                return false;
            }

            var parentOperationIdStr = env_cv.Substring(2 + c_guidLength + 1, c_guidLength);
            if (!Guid.TryParse(parentOperationIdStr, out parentOperationId))
            {
                return false;
            }

            var operationIdStr = env_cv.Substring(2 + c_guidLength + 1 + c_guidLength + 1, c_guidLength);
            if (!Guid.TryParse(operationIdStr, out operationId))
            {
                return false;
            }

            return true;
        }
        #endregion
    }
    #endregion
}
